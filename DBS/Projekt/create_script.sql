CREATE TABLE dnd_table(
    table_id INTEGER CONSTRAINT dnd_table_PK PRIMARY KEY,
    miniatures CHAR(1) NOT NULL,
    capacity INTEGER NOT NULL CHECK (capacity >= 0),
    dice CHAR(1) NOT NULL
);

CREATE TABLE player(
    player_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1 CONSTRAINT player_pk PRIMARY KEY,
    e_mail VARCHAR(255),
    user_name VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE dungeon_master(
    dungeon_master_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1 CONSTRAINT dungeon_master_pk PRIMARY KEY,
    e_mail VARCHAR(255),
    user_name VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE game_date (
    game_date_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1 CONSTRAINT game_date_pk PRIMARY KEY,
    game_datetime TIMESTAMP NOT NULL
);

CREATE TABLE dnd_session (
    table_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1,
    player_id INTEGER,
    dungeon_master_id INTEGER,
    game_date_id INTEGER,
    CONSTRAINT session_pk PRIMARY KEY (table_id, player_id, dungeon_master_id, game_date_id),
    FOREIGN KEY (table_id) REFERENCES dnd_table(table_id),
    FOREIGN KEY (player_id) REFERENCES player(player_id),
    FOREIGN KEY (dungeon_master_id) REFERENCES dungeon_master(dungeon_master_id),
    FOREIGN KEY (game_date_id) REFERENCES game_date(game_date_id)
);

CREATE TABLE adventure(
    adventure_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1 CONSTRAINT adventure_pk PRIMARY KEY,
    name VARCHAR(255) UNIQUE,
    recommended_level INTEGER CHECK (recommended_level > 0) -- if null any level is okay
);

CREATE TABLE loot(
    loot_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1 CONSTRAINT loot_pk PRIMARY KEY,
    description VARCHAR(255) UNIQUE
);

CREATE TABLE non_player_character(
    non_player_character_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1 CONSTRAINT npc_pk PRIMARY KEY,
    name VARCHAR(255) NOT NULL, -- npcs may have the same name
    challenge_rating NUMERIC (4,2) NOT NULL,
    experience_points INTEGER NOT NULL,
    alive VARCHAR (1) NOT NULL,
    world VARCHAR(255),
    FOREIGN KEY (world) REFERENCES adventure (name)
);

CREATE TABLE drop_table(
    loot INTEGER,
    drops_form INTEGER,
    CONSTRAINT drop_table_pk PRIMARY KEY (loot, drops_form),
    FOREIGN KEY (loot) REFERENCES loot (loot_id),
    FOREIGN KEY (drops_form) REFERENCES non_player_character (non_player_character_id)
);

CREATE TABLE party(
    party_name VARCHAR(255) CONSTRAINT party_pk PRIMARY KEY
);

CREATE TABLE player_character(
    player_character_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1 CONSTRAINT pc_pk PRIMARY KEY,
    name VARCHAR(255) NOT NULL, -- pcs may have the same name
    character_of INTEGER NOT NULL,
    class VARCHAR(255) NOT NULL,
    race VARCHAR(255) NOT NULL,
    party VARCHAR(255),
    alive INTEGER,
    trade_partner INTEGER,
    gold INTEGER,
    character_level INTEGER NOT NULL,
    CONSTRAINT fk_character_of FOREIGN KEY (character_of) REFERENCES player(player_id) ON DELETE CASCADE,
    CONSTRAINT fk_party FOREIGN KEY (party) REFERENCES party (party_name),
    CONSTRAINT fk_trade_partner FOREIGN KEY (trade_partner) REFERENCES player_character(player_character_id),
    CONSTRAINT chk_class CHECK(class IN ('BARBARIAN', 'BARD', 'CLERIC', 'DRUID', 'FIGHTER', 'MONK', 'PALADIN', 'RANGER', 'ROGUE', 'SORCERER', 'WARLOCK', 'WIZARD', 'ARTIFICER')),
    CONSTRAINT chk_race CHECK(race IN('DRAGONBORN', 'DWARF', 'ELF', 'GNOME', 'HALF_ELF', 'HALFLING', 'HALF_ORC', 'HUMAN', 'TIEFLING'))
);

CREATE TABLE equipment(
    equipment_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1 CONSTRAINT equipment_pk PRIMARY KEY,
    description VARCHAR(255) UNIQUE
);

CREATE TABLE has_equipment(
    equipment INTEGER,
    owned_by INTEGER,
    CONSTRAINT has_equipment_pk PRIMARY KEY (equipment, owned_by),
    FOREIGN KEY (equipment) REFERENCES equipment(equipment_id),
    FOREIGN KEY (owned_by) REFERENCES player_character(player_character_id) ON DELETE CASCADE
);

CREATE TABLE spell(
    spell_id INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1 CONSTRAINT spell_pk PRIMARY KEY,
    description VARCHAR(255) UNIQUE
);

CREATE TABLE has_spell(
    spell INTEGER,
    casted_by INTEGER,
    CONSTRAINT has_spell_pk PRIMARY KEY (spell, casted_by), 
    FOREIGN KEY (spell) REFERENCES spell(spell_id),
    FOREIGN KEY (casted_by) REFERENCES player_character(player_character_id) ON DELETE CASCADE
);

CREATE TABLE runs(
    dungeon_master INTEGER,
    adventure INTEGER,
    CONSTRAINT runs_pk PRIMARY KEY (dungeon_master, adventure),
    FOREIGN KEY (dungeon_master) REFERENCES dungeon_master(dungeon_master_id),
    FOREIGN KEY (adventure) REFERENCES adventure(adventure_id)
);

CREATE TABLE fight(
    player_character INTEGER,
    non_player_character INTEGER,
    pc_won VARCHAR(1),
    CONSTRAINT fight_pk PRIMARY KEY (player_character, non_player_character),
    FOREIGN KEY (player_character) REFERENCES player_character (player_character_id),
    FOREIGN KEY (non_player_character) REFERENCES non_player_character (non_player_character_id)
);

-- auto inc mit seq und trig
CREATE SEQUENCE dnd_table_sequence START WITH 1;

CREATE OR REPLACE TRIGGER dnd_table_trigger_pk
BEFORE INSERT ON dnd_table
FOR EACH ROW
BEGIN
    SELECT dnd_table_sequence.NEXTVAL
    INTO :new.table_id
    FROM dual;
END;
/

-- trigger zum checken das nicht mehr spieler an einem table sitzen als cap
CREATE OR REPLACE TRIGGER check_capacity
BEFORE INSERT ON dnd_session
FOR EACH ROW
DECLARE
  current_capacity INTEGER;
  table_capacity INTEGER;
BEGIN
  SELECT capacity INTO table_capacity FROM dnd_table WHERE table_id = :new.table_id;
  SELECT COUNT(*) INTO current_capacity FROM dnd_session WHERE table_id = :new.table_id;
  IF current_capacity + 2 > table_capacity THEN
    RAISE_APPLICATION_ERROR(-20001, 'Table capacity exceeded');
  END IF;
END;
/
-- gibt pro player den reichsten char aus
CREATE VIEW richest_player_character AS -- TODO: fix type chracter_name -> character_name and rerun the database
SELECT p.player_id, p.user_name, pc.name AS chracter_name, pc.gold
FROM player p
INNER JOIN player_character pc ON p.player_id = pc.character_of
WHERE
    (p.player_id, pc.gold) IN (
        SELECT character_of, MAX(gold)
        FROM player_character
        GROUP BY character_of
    );

CREATE VIEW party_gold_summary AS
SELECT p.party_name, SUM(pc.gold) AS total_gold
FROM party p
LEFT JOIN player_character pc ON p.party_name = pc.party
GROUP BY p.party_name;

-- gibt gruppen aus welche eine avg lvl von 15 haben
CREATE VIEW end_game_party AS
SELECT p.party_name, AVG(pc.character_level) AS average_level
FROM party p
JOIN player_character pc ON p.party_name = pc.party
GROUP BY p.party_name
HAVING AVG(pc.character_level) > 15;
